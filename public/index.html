<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>AI Quota Monitor</title>
<style>
:root {
  --bg: #0d1117; --bg2: #161b22; --bg3: #21262d;
  --fg: #c9d1d9; --fg2: #8b949e; --fg3: #484f58;
  --ok: #7ee787; --warn: #f0d050; --crit: #ffa198; --blue: #79c0ff;
  --radius: 8px; --font: 'JetBrains Mono', 'SF Mono', 'Fira Code', monospace;
}
* { margin: 0; padding: 0; box-sizing: border-box; }
body { font-family: var(--font); background: var(--bg); color: var(--fg); min-height: 100vh; }
.container { max-width: 960px; margin: 0 auto; padding: 24px 16px; }
h1 { font-size: 1.1rem; color: var(--fg2); margin-bottom: 16px; }
h1 span { color: var(--ok); }
.subtitle { font-size: 0.75rem; color: var(--fg3); margin-top: 24px; margin-bottom: 0; }

/* Setup section */
.setup { background: var(--bg2); border: 1px solid var(--bg3); border-radius: var(--radius); padding: 16px; margin-bottom: 16px; }
.setup summary { cursor: pointer; font-size: 0.85rem; color: var(--blue); user-select: none; }
.setup summary:hover { text-decoration: underline; }
.setup[open] summary { margin-bottom: 12px; }
.field { margin-bottom: 12px; }
.field label { display: block; font-size: 0.75rem; color: var(--fg2); margin-bottom: 4px; }
.field .row { display: flex; gap: 8px; }
.field input { flex: 1; background: var(--bg); border: 1px solid var(--bg3); color: var(--fg); padding: 8px 10px;
  border-radius: 4px; font-family: var(--font); font-size: 0.8rem; outline: none; }
.field input:focus { border-color: var(--blue); }
.field input::placeholder { color: var(--fg3); }
.help { font-size: 0.7rem; color: var(--fg3); margin-top: 8px; line-height: 1.6; }
.help-title { font-size: 0.72rem; color: var(--fg2); margin-bottom: 6px; }
.cmd-list { display: flex; flex-direction: column; gap: 6px; }
.cmd-item { display: flex; align-items: stretch; background: var(--bg); border: 1px solid var(--bg3); border-radius: 4px; overflow: hidden; }
.cmd-os { flex-shrink: 0; width: 70px; display: flex; align-items: center; justify-content: center;
  background: var(--bg3); font-size: 0.65rem; color: var(--fg2); font-weight: 600; text-align: center; padding: 6px 4px; }
.cmd-code { flex: 1; padding: 8px 10px; font-size: 0.67rem; color: var(--fg);
  font-family: var(--font); line-height: 1.4; background: transparent; border: none; outline: none; min-width: 0; }
.cmd-copy { flex-shrink: 0; display: flex; align-items: center; justify-content: center; width: 40px;
  background: transparent; border: none; border-left: 1px solid var(--bg3); color: var(--fg3);
  cursor: pointer; font-size: 0.75rem; transition: background .15s, color .15s; }
.cmd-copy:hover { background: var(--bg3); color: var(--fg); }
.cmd-copy.copied { color: var(--ok); }
.account-group { margin-bottom: 14px; }
.account-list { display: flex; flex-direction: column; gap: 8px; }
.account-row { display: grid; grid-template-columns: 160px 1fr auto; gap: 8px; }
.account-row input { width: 100%; }
.account-token { -webkit-text-security: disc; text-security: disc; }
.btn-mini { background: var(--bg2); border: 1px solid var(--bg3); color: var(--fg2); padding: 6px 10px;
  border-radius: 4px; cursor: pointer; font-family: var(--font); font-size: 0.7rem; }
.btn-mini:hover { background: var(--bg3); color: var(--fg); }
.btn-add { margin-top: 8px; }

/* Controls */
.controls { display: flex; gap: 8px; align-items: center; margin: 16px 0; flex-wrap: wrap; }
.controls button { background: var(--bg2); border: 1px solid var(--bg3); color: var(--fg); padding: 6px 14px;
  border-radius: 4px; cursor: pointer; font-family: var(--font); font-size: 0.75rem; transition: background .15s; }
.controls button:hover { background: var(--bg3); }
.controls button.active { border-color: var(--ok); color: var(--ok); }
.controls .spacer { flex: 1; }
.controls .status { font-size: 0.7rem; color: var(--fg3); }

/* Service cards */
.card { background: var(--bg2); border: 1px solid var(--bg3); border-radius: var(--radius); padding: 16px; }
.card-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; }
.card-label { font-size: 0.85rem; font-weight: 600; }
.card-status { font-size: 0.7rem; padding: 2px 8px; border-radius: 10px; }
.card-status.ok { background: rgba(126,231,135,.15); color: var(--ok); }
.card-status.warning { background: rgba(240,208,80,.15); color: var(--warn); }
.card-status.critical { background: rgba(255,161,152,.15); color: var(--crit); }
.card-status.exhausted { background: rgba(255,161,152,.3); color: var(--crit); }
.card-status.unknown { background: var(--bg3); color: var(--fg3); }
.card-status.error { background: rgba(255,161,152,.1); color: var(--fg3); }

/* Dashboard grid */
#dashboard { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }
.card-header-left { display: flex; align-items: center; gap: 8px; }
.card-logo { flex-shrink: 0; width: 16px; height: 16px; color: var(--fg2); display: flex; align-items: center; }
.card-logo svg { width: 16px; height: 16px; }

.window { margin-bottom: 10px; }
.window:last-child { margin-bottom: 0; }
.window-header { display: flex; justify-content: space-between; font-size: 0.72rem; color: var(--fg2); margin-bottom: 4px; }
.bar-track { height: 6px; background: var(--bg); border-radius: 3px; overflow: hidden; }
.bar-fill { height: 100%; border-radius: 3px; transition: width .5s ease, background .3s; }
.bar-fill.ok { background: var(--ok); }
.bar-fill.warning { background: var(--warn); }
.bar-fill.critical { background: var(--crit); }
.bar-fill.exhausted { background: var(--crit); }
/* Elapsed time bar */
.bar-track-elapsed { height: 4px; margin-top: 2px; }
.bar-fill.elapsed { background: var(--blue); opacity: 0.45; }
.reset-info { font-size: 0.78rem; color: var(--blue); margin-top: 4px; text-align: right; font-weight: 500; }
/* Polling countdown ring */
.poll-ring-wrap { display: flex; align-items: center; }
.poll-ring-wrap svg { display: block; }

/* Empty state */
.empty { text-align: center; padding: 48px 16px; color: var(--fg3); font-size: 0.8rem; line-height: 1.8; }

/* Log */
.log-section { margin-top: 24px; }
.log-section summary { font-size: 0.75rem; color: var(--fg3); cursor: pointer; }
.log-list { max-height: 200px; overflow-y: auto; margin-top: 8px; font-size: 0.65rem; color: var(--fg3); line-height: 1.8; }
.log-list .warn { color: var(--warn); }
.log-list .crit { color: var(--crit); }
.log-list .ok { color: var(--ok); }

/* Raw response viewer */
.raw { margin-top: 16px; }
.raw summary { font-size: 0.75rem; color: var(--fg3); cursor: pointer; }
.raw pre { background: var(--bg); border: 1px solid var(--bg3); border-radius: 4px; padding: 12px;
  margin-top: 8px; font-size: 0.65rem; overflow-x: auto; max-height: 300px; overflow-y: auto; color: var(--fg2); }

@media (max-width: 480px) {
  .container { padding: 16px 10px; }
  #dashboard { grid-template-columns: 1fr; }
  .card { padding: 12px; }
  .account-row { grid-template-columns: 1fr; }
  .btn-remove-account { width: 100%; }
}
</style>
</head>
<body>
<div class="container">
  <h1>âš¡ AI Quota <span>Monitor</span></h1>

  <!-- Dashboard -->
  <div id="dashboard"></div>

  <!-- Controls -->
  <div class="controls">
    <button id="btn-start">â–¶ é–‹å§‹</button>
    <button id="btn-poll">âŸ³ ä»Šã™ãå–å¾—</button>
    <button id="btn-notify">ğŸ”” é€šçŸ¥è¨±å¯</button>
    <div class="spacer"></div>
    <div class="poll-ring-wrap" id="poll-ring"></div>
    <span class="status" id="poll-status"></span>
  </div>

  <!-- Token Setup -->
  <details class="setup" id="setup">
    <summary>ğŸ”‘ ãƒˆãƒ¼ã‚¯ãƒ³è¨­å®š</summary>

    <div class="field account-group">
      <label>Claude Code ã‚¢ã‚«ã‚¦ãƒ³ãƒˆ (åå‰ + OAuth Token)</label>
      <div class="account-list" id="claude-accounts"></div>
      <button class="btn-mini btn-add" id="btn-add-claude" type="button">+ Claude ã‚’è¿½åŠ </button>
      <div class="help">
        <div class="help-title">å–å¾—æ–¹æ³•:</div>
        <div class="cmd-list">
          <div class="cmd-item">
            <span class="cmd-os">macOS</span>
            <input class="cmd-code" type="text" readonly value="security find-generic-password -s &quot;Claude Code-credentials&quot; -w | python3 -c &quot;import sys,json; print(json.loads(sys.stdin.read())['claudeAiOauth']['accessToken'])&quot;">
            <button class="cmd-copy" type="button" title="ã‚³ãƒ”ãƒ¼">â§‰</button>
          </div>
          <div class="cmd-item">
            <span class="cmd-os">Linux</span>
            <input class="cmd-code" type="text" readonly value="cat ~/.claude/.credentials.json | jq -r '.claudeAiOauth.accessToken'">
            <button class="cmd-copy" type="button" title="ã‚³ãƒ”ãƒ¼">â§‰</button>
          </div>
          <div class="cmd-item">
            <span class="cmd-os">Windows</span>
            <input class="cmd-code" type="text" readonly value="(Get-Content &quot;$env:USERPROFILE\.claude\.credentials.json&quot; -Raw | ConvertFrom-Json).claudeAiOauth.accessToken">
            <button class="cmd-copy" type="button" title="ã‚³ãƒ”ãƒ¼">â§‰</button>
          </div>
        </div>
      </div>
    </div>

    <div class="field account-group">
      <label>Codex ã‚¢ã‚«ã‚¦ãƒ³ãƒˆ (åå‰ + Access Token)</label>
      <div class="account-list" id="codex-accounts"></div>
      <button class="btn-mini btn-add" id="btn-add-codex" type="button">+ Codex ã‚’è¿½åŠ </button>
      <div class="help">
        <div class="help-title">å–å¾—æ–¹æ³•:</div>
        <div class="cmd-list">
          <div class="cmd-item">
            <span class="cmd-os">Linux<br>macOS</span>
            <input class="cmd-code" type="text" readonly value="cat ~/.codex/auth.json | jq -r '.tokens.access_token'">
            <button class="cmd-copy" type="button" title="ã‚³ãƒ”ãƒ¼">â§‰</button>
          </div>
          <div class="cmd-item">
            <span class="cmd-os">macOS<br>(Keychain)</span>
            <input class="cmd-code" type="text" readonly value="security find-generic-password -s &quot;Codex Auth&quot; -w | jq -r '.tokens.access_token'">
            <button class="cmd-copy" type="button" title="ã‚³ãƒ”ãƒ¼">â§‰</button>
          </div>
          <div class="cmd-item">
            <span class="cmd-os">Windows</span>
            <input class="cmd-code" type="text" readonly value="(Get-Content &quot;$env:USERPROFILE\.codex\auth.json&quot; -Raw | ConvertFrom-Json).tokens.access_token">
            <button class="cmd-copy" type="button" title="ã‚³ãƒ”ãƒ¼">â§‰</button>
          </div>
        </div>
      </div>
    </div>

    <div class="field">
      <label>ãƒãƒ¼ãƒªãƒ³ã‚°é–“éš” (ç§’)</label>
      <div class="row">
        <input type="number" id="poll-interval" value="120" min="30" max="600" style="max-width:100px">
      </div>
    </div>
  </details>

  <!-- Raw responses for debugging -->
  <details class="raw" id="raw-section">
    <summary>ğŸ” ç”Ÿãƒ¬ã‚¹ãƒãƒ³ã‚¹ (ãƒ‡ãƒãƒƒã‚°ç”¨)</summary>
    <pre id="raw-data">ã¾ã å–å¾—ã•ã‚Œã¦ã„ã¾ã›ã‚“</pre>
  </details>

  <!-- Log -->
  <details class="log-section">
    <summary>ğŸ“‹ ãƒ­ã‚°</summary>
    <div class="log-list" id="log-list"></div>
  </details>

  <p class="subtitle">ãƒ–ãƒ©ã‚¦ã‚¶å®Œçµ â€” ãƒˆãƒ¼ã‚¯ãƒ³ã¯ã‚µãƒ¼ãƒãƒ¼ã«ä¿å­˜ã•ã‚Œã¾ã›ã‚“</p>
</div>

<script>
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// State
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const state = {
  polling: false,
  timer: null,
  pollStartedAt: null,
  pollInterval: 120,
  ringTimer: null,
  accounts: { claude: [], codex: [] }, // [{ id, name, token }]
  services: {},   // { id: { label, windows: [{name, utilization, resetsAt}], status, lastRaw } }
  logs: [],
  rawResponses: {},
  history: {},    // { 'serviceKey:windowName': [util1, util2, ...] }
};

const THRESHOLDS = { warning: 75, critical: 90, exhausted: 100 };
const SERVICE_META = {
  claude: {
    label: 'Claude Code', listId: '#claude-accounts', addBtnId: '#btn-add-claude',
    icon: '<svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="2.2" stroke-linecap="round"><line x1="8" y1="1" x2="8" y2="15"/><line x1="1.9" y1="4.5" x2="14.1" y2="11.5"/><line x1="14.1" y1="4.5" x2="1.9" y2="11.5"/></svg>',
  },
  codex: {
    label: 'Codex', listId: '#codex-accounts', addBtnId: '#btn-add-codex',
    icon: '<svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.3"><path d="M8 1l6.1 3.5v7L8 15l-6.1-3.5v-7z"/><path d="M8 5l3 1.75v3.5L8 12l-3-1.75v-3.5z"/></svg>',
  },
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Copy-to-clipboard for command snippets
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
document.addEventListener('click', e => {
  const btn = e.target.closest('.cmd-copy');
  if (!btn) return;
  const code = btn.parentElement.querySelector('.cmd-code').value;
  navigator.clipboard.writeText(code).then(() => {
    btn.textContent = 'âœ“';
    btn.classList.add('copied');
    setTimeout(() => { btn.textContent = 'â§‰'; btn.classList.remove('copied'); }, 1500);
  });
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Utils
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const $ = s => document.querySelector(s);
const log = (msg, level = '') => {
  const ts = new Date().toLocaleTimeString();
  state.logs.unshift({ ts, msg, level });
  if (state.logs.length > 200) state.logs.length = 200;
  renderLogs();
};

function classifyUtilization(pct) {
  if (pct >= THRESHOLDS.exhausted) return 'exhausted';
  if (pct >= THRESHOLDS.critical) return 'critical';
  if (pct >= THRESHOLDS.warning) return 'warning';
  return 'ok';
}

function formatReset(epoch) {
  if (!epoch) return '';
  const d = typeof epoch === 'number' ? new Date(epoch * 1000) : new Date(epoch);
  if (isNaN(d)) return '';
  const now = new Date();
  const diff = d - now;
  if (diff <= 0) return 'ãƒªã‚»ãƒƒãƒˆæ¸ˆã¿';
  const h = Math.floor(diff / 3600000);
  const m = Math.floor((diff % 3600000) / 60000);
  const dateStr = d.toLocaleDateString('ja-JP', { month: 'short', day: 'numeric' });
  const timeStr = d.toLocaleTimeString('ja-JP', { hour: '2-digit', minute: '2-digit' });
  if (h >= 24) return `${dateStr} ${timeStr} (ã‚ã¨${Math.floor(h/24)}æ—¥${h%24}æ™‚é–“)`;
  if (h > 0) return `${timeStr} (ã‚ã¨${h}æ™‚é–“${m}åˆ†)`;
  return `${timeStr} (ã‚ã¨${m}åˆ†)`;
}

function notify(title, body) {
  if (Notification.permission === 'granted') {
    new Notification(title, { body, icon: 'âš¡' });
  }
}

function makeAccountId(service) {
  return `${service}-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;
}

function defaultAccount(service, idx = 0) {
  const base = SERVICE_META[service].label;
  return { id: makeAccountId(service), name: `${base} ${idx + 1}`, token: '' };
}

function accountFromRow(row) {
  const id = row.dataset.accountId || '';
  const name = row.querySelector('.account-name')?.value?.trim() || '';
  const token = row.querySelector('.account-token')?.value?.trim() || '';
  return { id, name, token };
}

function readAccountsFromDom(service) {
  const list = $(SERVICE_META[service].listId);
  const rows = Array.from(list.querySelectorAll('.account-row'));
  return rows.map(accountFromRow);
}

function writeAccountsToDom(service, accounts) {
  const list = $(SERVICE_META[service].listId);
  list.innerHTML = '';
  for (const acc of accounts) {
    const row = document.createElement('div');
    row.className = 'account-row';
    row.dataset.accountId = acc.id || makeAccountId(service);
    row.innerHTML = `
      <input class="account-name" type="text" placeholder="è¡¨ç¤ºå" value="${escHtml(acc.name || '')}">
      <input class="account-token" type="text" placeholder="eyJhbG... / sk-..." value="${escHtml(acc.token || '')}">
      <button class="btn-mini btn-remove-account" type="button">å‰Šé™¤</button>
    `;
    row.querySelector('.btn-remove-account').addEventListener('click', () => {
      row.remove();
      if (!list.querySelector('.account-row')) addAccountRow(service);
      persistSetup();
    });
    row.querySelector('.account-name').addEventListener('input', persistSetup);
    row.querySelector('.account-token').addEventListener('input', persistSetup);
    list.appendChild(row);
  }
}

function addAccountRow(service, account = null) {
  const existing = readAccountsFromDom(service);
  const next = account || defaultAccount(service, existing.length);
  writeAccountsToDom(service, [...existing, next]);
  persistSetup();
}

function collectAccounts() {
  const collected = {};
  for (const service of Object.keys(SERVICE_META)) {
    const rows = readAccountsFromDom(service);
    collected[service] = rows.map((acc, idx) => ({
      id: acc.id || makeAccountId(service),
      name: acc.name || `${SERVICE_META[service].label} ${idx + 1}`,
      token: acc.token || '',
    }));
  }
  return collected;
}

function persistSetup() {
  try {
    const accounts = collectAccounts();
    sessionStorage.setItem('qm-accounts', JSON.stringify(accounts));
    sessionStorage.setItem('qm-interval', String(Math.max(30, parseInt($('#poll-interval').value) || 120)));
  } catch {}
}

function persistLastData() {
  try {
    sessionStorage.setItem('qm-services', JSON.stringify(state.services));
    sessionStorage.setItem('qm-raw', JSON.stringify(state.rawResponses));
    sessionStorage.setItem('qm-history', JSON.stringify(state.history));
    sessionStorage.setItem('qm-fetched-at', new Date().toISOString());
  } catch {}
}

function persistPollingState() {
  try {
    sessionStorage.setItem('qm-poll-state', JSON.stringify({
      startedAt: state.pollStartedAt,
      interval: state.pollInterval,
    }));
  } catch {}
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// API proxy base URL detection
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function apiBase() {
  // Works both in Vercel deployment and local dev
  return window.location.origin;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Claude Code fetcher
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function fetchClaude(token) {
  const resp = await fetch(`${apiBase()}/api/claude`, {
    headers: { 'x-quota-token': token },
  });
  const data = await resp.json();
  if (!resp.ok) throw new Error(data.error || `HTTP ${resp.status}`);
  return data;
}

function parseClaude(data) {
  const windows = [];
  const labels = {
    five_hour: '5æ™‚é–“',
    seven_day: '7æ—¥é–“',
    seven_day_opus: '7æ—¥é–“ (Opus)',
    seven_day_sonnet: '7æ—¥é–“ (Sonnet)',
    seven_day_oauth_apps: '7æ—¥é–“ (OAuth Apps)',
    seven_day_cowork: '7æ—¥é–“ (Cowork)',
  };
  const winSecMap = {
    five_hour: 18000,
    seven_day: 604800, seven_day_opus: 604800, seven_day_sonnet: 604800,
    seven_day_oauth_apps: 604800, seven_day_cowork: 604800,
  };
  const preferredOrder = Object.keys(labels);
  const pushed = new Set();
  const pushWindow = (key, name) => {
    const w = data[key];
    if (!w || typeof w !== 'object') return;
    if (typeof w.utilization !== 'number') return;
    windows.push({
      name,
      utilization: w.utilization,
      resetsAt: w.resets_at || null,
      status: classifyUtilization(w.utilization),
      windowSeconds: winSecMap[key] || (key.startsWith('seven_day') ? 604800 : key.includes('hour') ? 18000 : null),
    });
    pushed.add(key);
  };

  for (const key of preferredOrder) {
    pushWindow(key, labels[key]);
  }
  for (const [key, value] of Object.entries(data)) {
    if (pushed.has(key)) continue;
    if (!value || typeof value !== 'object') continue;
    if (typeof value.utilization !== 'number') continue;
    const name = key.replaceAll('_', ' ');
    pushWindow(key, name);
  }
  return windows;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Codex fetcher
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function fetchCodex(token) {
  const resp = await fetch(`${apiBase()}/api/codex`, {
    headers: { 'x-quota-token': token },
  });

  // Capture upstream headers for debugging
  const upstreamHeaders = {};
  for (const [k, v] of resp.headers.entries()) {
    if (k.startsWith('x-upstream-')) upstreamHeaders[k] = v;
  }

  const text = await resp.text();
  let data;
  try { data = JSON.parse(text); } catch { data = { _raw: text }; }
  data._upstreamHeaders = upstreamHeaders;

  if (!resp.ok) throw new Error(data.error || data.detail || `HTTP ${resp.status}`);
  return data;
}

function parseCodex(data) {
  const windows = [];
  const toNumber = (v) => {
    const n = Number(v);
    return Number.isFinite(n) ? n : null;
  };
  const normalizeWindowName = (seconds, fallback) => {
    if (fallback) return fallback;
    const sec = toNumber(seconds);
    if (sec === 18000) return '5æ™‚é–“';
    if (sec === 604800) return '7æ—¥é–“';
    if (sec === 86400) return '24æ™‚é–“';
    if (!sec || sec <= 0) return 'ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦';
    if (sec % 86400 === 0) return `${Math.round(sec / 86400)}æ—¥é–“`;
    return `${Math.round(sec / 3600)}æ™‚é–“`;
  };
  const pushWindow = (windowData, label, parent) => {
    if (!windowData || typeof windowData !== 'object') return;
    const utilization =
      toNumber(windowData.used_percent ?? windowData.usedPercent ?? windowData.utilization) ??
      (() => {
        const used = toNumber(windowData.used);
        const limit = toNumber(windowData.limit);
        if (used !== null && limit && limit > 0) return (used / limit) * 100;
        return 0;
      })();
    const limitReached = windowData.limit_reached ?? windowData.limitReached ?? parent?.limit_reached ?? parent?.limitReached;
    const allowed = windowData.allowed ?? parent?.allowed;
    let status = classifyUtilization(utilization);
    if (limitReached === true || allowed === false) status = 'exhausted';
    const ws = toNumber(windowData.limit_window_seconds ?? windowData.limitWindowSeconds) || null;
    windows.push({
      name: normalizeWindowName(ws, label),
      utilization,
      resetsAt: windowData.reset_at ?? windowData.resetAt ?? windowData.resets_at ?? windowData.resetsAt ?? null,
      status,
      windowSeconds: ws,
    });
  };
  const parseWhamRateLimit = (block, prefix) => {
    if (!block || typeof block !== 'object') return;
    const primary = block.primary_window ?? block.primaryWindow ?? block.primary;
    const secondary = block.secondary_window ?? block.secondaryWindow ?? block.secondary;
    const primaryLabel = prefix ? `${prefix} (primary)` : null;
    const secondaryLabel = prefix ? `${prefix} (secondary)` : null;
    pushWindow(primary, primaryLabel, block);
    pushWindow(secondary, secondaryLabel, block);
  };

  // Current wham/usage shape:
  // {
  //   rate_limit: { primary_window, secondary_window, allowed, limit_reached },
  //   code_review_rate_limit: { primary_window, ... },
  //   additional_rate_limits: [...]
  // }
  parseWhamRateLimit(data.rate_limit, null);
  parseWhamRateLimit(data.code_review_rate_limit, 'Code Review');
  if (Array.isArray(data.additional_rate_limits)) {
    for (const [idx, block] of data.additional_rate_limits.entries()) {
      parseWhamRateLimit(block, block?.name || `Additional ${idx + 1}`);
    }
  } else {
    parseWhamRateLimit(data.additional_rate_limits, 'Additional');
  }

  // Backward-compatible fallback parsers
  if (windows.length === 0) {
    const rl = data.rate_limits || data.rateLimits || data;
    if (rl.primary || rl.secondary) {
      pushWindow(rl.primary, '5æ™‚é–“', rl);
      pushWindow(rl.secondary, '7æ—¥é–“', rl);
    }
  }
  if (windows.length === 0) {
    const arr = data.windows || data.limits || data.rate_limits;
    if (Array.isArray(arr)) {
      for (const w of arr) {
        pushWindow(w, w.name || w.label || w.window || null, null);
      }
    }
  }
  if (windows.length === 0) {
    for (const [key, name] of [['five_hour', '5æ™‚é–“'], ['fiveHour', '5æ™‚é–“'], ['weekly', '7æ—¥é–“'], ['seven_day', '7æ—¥é–“']]) {
      if (data[key] && typeof data[key] === 'object') {
        pushWindow(data[key], name, data[key]);
      }
    }
  }

  if (windows.length === 0) {
    windows.push({ name: '(ä¸æ˜ãªå½¢å¼)', utilization: 0, resetsAt: null, status: 'unknown' });
  }

  return windows;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Poll orchestrator
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function pollAll() {
  state.accounts = collectAccounts();
  persistSetup();
  let anySuccess = false;
  const nextServices = {};
  state.rawResponses = {};
  const statusOrder = ['unknown', 'ok', 'warning', 'critical', 'exhausted'];
  const worstOf = (windows) => windows.reduce((a, w) => (
    statusOrder.indexOf(w.status) > statusOrder.indexOf(a) ? w.status : a
  ), 'ok');

  for (const acc of state.accounts.claude) {
    if (!acc.token) continue;
    const serviceKey = `claude:${acc.id}`;
    const label = `${SERVICE_META.claude.label}: ${acc.name}`;
    try {
      const data = await fetchClaude(acc.token);
      state.rawResponses[serviceKey] = data;
      const windows = parseClaude(data);
      for (const w of windows) { recordHistory(`${serviceKey}:${w.name}`, w.utilization); }
      const worstStatus = worstOf(windows);

      const prev = state.services[serviceKey]?.status;
      nextServices[serviceKey] = { label, windows, status: worstStatus };

      if (prev && prev !== worstStatus) {
        if (worstStatus === 'critical' || worstStatus === 'exhausted') {
          notify(`${label} âš ï¸`, `ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹: ${worstStatus} â€” ${windows.map(w => `${w.name}: ${w.utilization}%`).join(', ')}`);
          log(`${label} â†’ ${worstStatus}`, 'crit');
        } else if (worstStatus === 'ok' && (prev === 'critical' || prev === 'exhausted')) {
          notify(`${label} âœ…`, 'ã‚¯ã‚©ãƒ¼ã‚¿ãŒå›å¾©ã—ã¾ã—ãŸ');
          log(`${label} â†’ ok (å›å¾©)`, 'ok');
        }
      }
      anySuccess = true;
      log(`${label} å–å¾—æˆåŠŸ: ${windows.map(w => `${w.name}=${w.utilization}%`).join(', ')}`);
    } catch (e) {
      nextServices[serviceKey] = { label, windows: [], status: 'error', error: e.message };
      log(`${label} ã‚¨ãƒ©ãƒ¼: ${e.message}`, 'warn');
    }
  }

  for (const acc of state.accounts.codex) {
    if (!acc.token) continue;
    const serviceKey = `codex:${acc.id}`;
    const label = `${SERVICE_META.codex.label}: ${acc.name}`;
    try {
      const data = await fetchCodex(acc.token);
      state.rawResponses[serviceKey] = data;
      const windows = parseCodex(data);
      for (const w of windows) { recordHistory(`${serviceKey}:${w.name}`, w.utilization); }
      const worstStatus = worstOf(windows);

      const prev = state.services[serviceKey]?.status;
      nextServices[serviceKey] = { label, windows, status: worstStatus };

      if (prev && prev !== worstStatus) {
        if (worstStatus === 'critical' || worstStatus === 'exhausted') {
          notify(`${label} âš ï¸`, `ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹: ${worstStatus}`);
          log(`${label} â†’ ${worstStatus}`, 'crit');
        } else if (worstStatus === 'ok' && (prev === 'critical' || prev === 'exhausted')) {
          notify(`${label} âœ…`, 'ã‚¯ã‚©ãƒ¼ã‚¿ãŒå›å¾©ã—ã¾ã—ãŸ');
          log(`${label} â†’ ok (å›å¾©)`, 'ok');
        }
      }
      anySuccess = true;
      log(`${label} å–å¾—æˆåŠŸ: ${windows.map(w => `${w.name}=${w.utilization}%`).join(', ')}`);
    } catch (e) {
      nextServices[serviceKey] = { label, windows: [], status: 'error', error: e.message };
      log(`${label} ã‚¨ãƒ©ãƒ¼: ${e.message}`, 'warn');
    }
  }

  state.services = nextServices;

  const allAccounts = [...state.accounts.claude, ...state.accounts.codex];
  const withToken = allAccounts.filter(a => a.token);
  if (withToken.length === 0) {
    log('ãƒˆãƒ¼ã‚¯ãƒ³ãŒæœªè¨­å®š', 'warn');
  }

  render();
  persistLastData();
  return anySuccess;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// History & bar helpers
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function recordHistory(key, utilization) {
  if (!state.history[key]) state.history[key] = [];
  const arr = state.history[key];
  // If utilization dropped significantly (quota reset), clear history
  if (arr.length > 0 && utilization < arr[arr.length - 1] - 5) arr.length = 0;
  arr.push(utilization);
  if (arr.length > 10) arr.shift();
}

const STATUS_RGB = {
  ok: '126,231,135', warning: '240,208,80',
  critical: '255,161,152', exhausted: '255,161,152',
};

function buildBarGradient(history, status) {
  const rgb = STATUS_RGB[status] || STATUS_RGB.ok;
  if (!history || history.length <= 1) return '';
  const total = history[history.length - 1];
  if (total <= 0) return '';
  const stops = [];
  const n = history.length;
  for (let i = 0; i < n; i++) {
    const segStart = i === 0 ? 0 : history[i - 1];
    const segEnd = history[i];
    if (segEnd <= segStart) continue;
    const alpha = (0.6 + 0.4 * (i / Math.max(n - 1, 1))).toFixed(2);
    const pS = ((segStart / total) * 100).toFixed(1);
    const pE = ((segEnd / total) * 100).toFixed(1);
    stops.push(`rgba(${rgb},${alpha}) ${pS}%`, `rgba(${rgb},${alpha}) ${pE}%`);
  }
  if (stops.length === 0) return '';
  return `background:linear-gradient(to right,${stops.join(',')})`;
}

function calcElapsedPct(resetsAt, windowSeconds) {
  if (!resetsAt || !windowSeconds) return null;
  const d = typeof resetsAt === 'number' ? new Date(resetsAt * 1000) : new Date(resetsAt);
  if (isNaN(d)) return null;
  const remainSec = Math.max(0, (d - new Date()) / 1000);
  const elapsedSec = windowSeconds - remainSec;
  return Math.max(0, Math.min(100, (elapsedSec / windowSeconds) * 100));
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Polling countdown ring
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function updatePollRing() {
  const el = $('#poll-ring');
  if (!el) return;
  if (!state.polling || !state.pollStartedAt) { el.innerHTML = ''; return; }
  const elapsed = (Date.now() - state.pollStartedAt) / 1000;
  const remaining = Math.max(0, state.pollInterval - elapsed);
  const fraction = remaining / state.pollInterval;
  const R = 14, C = 2 * Math.PI * R;
  const offset = C * (1 - fraction);
  const color = fraction > 0.3 ? 'var(--ok)' : fraction > 0.1 ? 'var(--warn)' : 'var(--crit)';
  el.innerHTML = `<svg viewBox="0 0 36 36" width="32" height="32">
    <circle cx="18" cy="18" r="${R}" fill="none" stroke="var(--bg3)" stroke-width="2.5"/>
    <circle cx="18" cy="18" r="${R}" fill="none" stroke="${color}" stroke-width="2.5"
      stroke-dasharray="${C.toFixed(2)}" stroke-dashoffset="-${offset.toFixed(2)}"
      stroke-linecap="round" transform="rotate(-90 18 18)"/>
  </svg>`;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Render
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function render() {
  const dash = $('#dashboard');
  const entries = Object.entries(state.services);

  if (entries.length === 0) {
    dash.innerHTML = '<div class="empty">ãƒˆãƒ¼ã‚¯ãƒ³ã‚’è¨­å®šã—ã¦ã€Œé–‹å§‹ã€ã‚’æŠ¼ã—ã¦ãã ã•ã„</div>';
    return;
  }

  dash.innerHTML = entries.map(([id, svc]) => {
    const serviceType = id.split(':')[0];
    const meta = SERVICE_META[serviceType];
    const logoHtml = meta?.icon ? `<span class="card-logo">${meta.icon}</span>` : '';

    if (svc.error && svc.windows.length === 0) {
      return `<div class="card">
        <div class="card-header">
          <span class="card-header-left">${logoHtml}<span class="card-label">${svc.label}</span></span>
          <span class="card-status error">ã‚¨ãƒ©ãƒ¼</span>
        </div>
        <div style="font-size:.72rem;color:var(--crit)">${escHtml(svc.error)}</div>
      </div>`;
    }

    const windowsHtml = svc.windows.map(w => {
      const histKey = `${id}:${w.name}`;
      const hist = state.history[histKey] || [];
      const grad = buildBarGradient(hist, w.status);
      const barStyle = grad ? `${grad};width:${Math.min(w.utilization, 100)}%`
                            : `width:${Math.min(w.utilization, 100)}%`;
      const elPct = calcElapsedPct(w.resetsAt, w.windowSeconds);
      const elStr = elPct !== null ? ` / çµŒé ${elPct.toFixed(0)}%` : '';
      const elBar = elPct !== null
        ? `<div class="bar-track bar-track-elapsed"><div class="bar-fill elapsed" style="width:${Math.min(elPct, 100)}%"></div></div>`
        : '';
      return `<div class="window">
        <div class="window-header">
          <span>${w.name}</span>
          <span>ä½¿ç”¨ ${w.utilization.toFixed(1)}%${elStr}</span>
        </div>
        <div class="bar-track">
          <div class="bar-fill ${w.status}" style="${barStyle}"></div>
        </div>
        ${elBar}
        ${w.resetsAt ? `<div class="reset-info">ãƒªã‚»ãƒƒãƒˆ: ${formatReset(w.resetsAt)}</div>` : ''}
      </div>`;
    }).join('');

    return `<div class="card">
      <div class="card-header">
        <span class="card-header-left">${logoHtml}<span class="card-label">${svc.label}</span></span>
        <span class="card-status ${svc.status}">${svc.status}</span>
      </div>
      ${windowsHtml}
    </div>`;
  }).join('');

  // Raw data
  $('#raw-data').textContent = JSON.stringify(state.rawResponses, null, 2);
}

function renderLogs() {
  const el = $('#log-list');
  el.innerHTML = state.logs.slice(0, 50).map(l =>
    `<div class="${l.level}">[${l.ts}] ${escHtml(l.msg)}</div>`
  ).join('');
}

function escHtml(s) {
  return String(s)
    .replace(/&/g,'&amp;')
    .replace(/</g,'&lt;')
    .replace(/>/g,'&gt;')
    .replace(/"/g,'&quot;')
    .replace(/'/g,'&#39;');
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Controls
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function startPolling() {
  stopPolling();
  const intervalSec = Math.max(30, parseInt($('#poll-interval').value) || 120);
  state.polling = true;
  state.pollInterval = intervalSec;
  state.pollStartedAt = Date.now();
  persistPollingState();
  $('#btn-start').textContent = 'â¹ åœæ­¢';
  $('#btn-start').classList.add('active');
  updatePollStatus('å–å¾—ä¸­...');
  pollAll().then(() => { state.pollStartedAt = Date.now(); persistPollingState(); updatePollRing(); updateCountdown(); });
  state.timer = setInterval(() => {
    updatePollStatus('å–å¾—ä¸­...');
    pollAll().then(() => {
      state.pollStartedAt = Date.now();
      persistPollingState();
      updateCountdown();
    });
  }, intervalSec * 1000);
  state.ringTimer = setInterval(() => { updatePollRing(); updateCountdown(); }, 1000);
  persistSetup();
}

function stopPolling() {
  state.polling = false;
  if (state.timer) { clearInterval(state.timer); state.timer = null; }
  if (state.ringTimer) { clearInterval(state.ringTimer); state.ringTimer = null; }
  state.pollStartedAt = null;
  updatePollRing();
  sessionStorage.removeItem('qm-poll-state');
  $('#btn-start').textContent = 'â–¶ é–‹å§‹';
  $('#btn-start').classList.remove('active');
  updatePollStatus('åœæ­¢ä¸­');
}

function resumePolling(startedAt, intervalSec) {
  state.polling = true;
  state.pollInterval = intervalSec;
  $('#btn-start').textContent = 'â¹ åœæ­¢';
  $('#btn-start').classList.add('active');

  const doPoll = () => {
    updatePollStatus('å–å¾—ä¸­...');
    pollAll().then(() => {
      state.pollStartedAt = Date.now();
      persistPollingState();
      updateCountdown();
    });
  };
  const scheduleRegular = () => {
    state.timer = setInterval(doPoll, intervalSec * 1000);
  };

  const elapsed = (Date.now() - startedAt) / 1000;
  if (elapsed >= intervalSec) {
    state.pollStartedAt = Date.now();
    doPoll();
    scheduleRegular();
  } else {
    state.pollStartedAt = startedAt;
    updateCountdown();
    state.timer = setTimeout(() => {
      doPoll();
      scheduleRegular();
    }, (intervalSec - elapsed) * 1000);
  }

  state.ringTimer = setInterval(() => { updatePollRing(); updateCountdown(); }, 1000);
  updatePollRing();
}

function updatePollStatus(msg) {
  $('#poll-status').textContent = msg;
}

function updateCountdown() {
  if (!state.polling || !state.pollStartedAt) return;
  const elapsed = (Date.now() - state.pollStartedAt) / 1000;
  const remaining = Math.max(0, Math.ceil(state.pollInterval - elapsed));
  updatePollStatus(`æ¬¡å›æ›´æ–°: ${remaining}ç§’å¾Œ`);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Init
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
document.addEventListener('DOMContentLoaded', () => {
  // Restore setup from sessionStorage
  let restored = null;
  try {
    const raw = sessionStorage.getItem('qm-accounts');
    restored = raw ? JSON.parse(raw) : null;
    if (restored && typeof restored === 'object') {
      state.accounts.claude = Array.isArray(restored.claude) ? restored.claude : [];
      state.accounts.codex = Array.isArray(restored.codex) ? restored.codex : [];
    } else {
      // Backward compatibility with old single-token storage.
      const legacyClaude = sessionStorage.getItem('qm-claude') || '';
      const legacyCodex = sessionStorage.getItem('qm-codex') || '';
      if (legacyClaude) state.accounts.claude = [{ ...defaultAccount('claude', 0), token: legacyClaude }];
      if (legacyCodex) state.accounts.codex = [{ ...defaultAccount('codex', 0), token: legacyCodex }];
    }
    const iv = sessionStorage.getItem('qm-interval');
    if (iv) $('#poll-interval').value = iv;
  } catch {}
  if (state.accounts.claude.length === 0) state.accounts.claude = [defaultAccount('claude', 0)];
  if (state.accounts.codex.length === 0) state.accounts.codex = [defaultAccount('codex', 0)];
  writeAccountsToDom('claude', state.accounts.claude);
  writeAccountsToDom('codex', state.accounts.codex);

  // Open setup if no tokens registered
  const hasAnyToken = [...state.accounts.claude, ...state.accounts.codex].some(a => a.token);
  if (!hasAnyToken) $('#setup').open = true;

  // Restore last fetched data
  try {
    const svcs = sessionStorage.getItem('qm-services');
    const raw = sessionStorage.getItem('qm-raw');
    const fetchedAt = sessionStorage.getItem('qm-fetched-at');
    if (svcs) {
      state.services = JSON.parse(svcs);
      state.rawResponses = raw ? JSON.parse(raw) : {};
      const histRaw = sessionStorage.getItem('qm-history');
      if (histRaw) state.history = JSON.parse(histRaw);
      render();
      if (fetchedAt) log(`å‰å›å–å¾—: ${new Date(fetchedAt).toLocaleString()}`);
    }
  } catch {}

  $('#btn-start').addEventListener('click', () => {
    if (state.polling) { stopPolling(); return; }
    const accounts = collectAccounts();
    if (![...accounts.claude, ...accounts.codex].some(a => a.token)) {
      log('ãƒˆãƒ¼ã‚¯ãƒ³ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“', 'warn');
      $('#setup').open = true;
      return;
    }
    startPolling();
  });

  $('#btn-poll').addEventListener('click', () => {
    const accounts = collectAccounts();
    if (![...accounts.claude, ...accounts.codex].some(a => a.token)) {
      log('ãƒˆãƒ¼ã‚¯ãƒ³ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“', 'warn');
      $('#setup').open = true;
      return;
    }
    updatePollStatus('å–å¾—ä¸­...');
    pollAll().then(() => updatePollStatus('å–å¾—å®Œäº†'));
  });

  $('#btn-notify').addEventListener('click', async () => {
    const perm = await Notification.requestPermission();
    if (perm === 'granted') {
      log('é€šçŸ¥ãŒè¨±å¯ã•ã‚Œã¾ã—ãŸ', 'ok');
      notify('ãƒ†ã‚¹ãƒˆ', 'AI Quota Monitor ã®é€šçŸ¥ãŒæœ‰åŠ¹ã§ã™');
    } else {
      log('é€šçŸ¥ãŒæ‹’å¦ã•ã‚Œã¾ã—ãŸ', 'warn');
    }
  });
  $(SERVICE_META.claude.addBtnId).addEventListener('click', () => addAccountRow('claude'));
  $(SERVICE_META.codex.addBtnId).addEventListener('click', () => addAccountRow('codex'));
  $('#poll-interval').addEventListener('change', persistSetup);
  if (!restored) persistSetup();

  render();

  // Restore polling state
  try {
    const ps = JSON.parse(sessionStorage.getItem('qm-poll-state'));
    if (ps && ps.startedAt && ps.interval) {
      resumePolling(ps.startedAt, ps.interval);
    } else {
      updatePollStatus('åœæ­¢ä¸­');
    }
  } catch {
    updatePollStatus('åœæ­¢ä¸­');
  }
});
</script>
</body>
</html>
